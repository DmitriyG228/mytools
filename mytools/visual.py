# AUTOGENERATED! DO NOT EDIT! File to edit: 00_visual.ipynb (unless otherwise specified).

__all__ = ['mean_filter', 'visualize_array', 'extrapolate', 'expand_boundaries', 'crop_center_arr', 'apply_mask',
           'crop_zeros', 'crop_image_to_square', 'search_clip']

# Cell
from .tools import *
import numpy as np
import torch
from matplotlib import pyplot as plt
import requests

# Cell
#https://stackoverflow.com/questions/59831211/neighbours-of-a-cell-in-matrix-pytorch
import torch.nn.functional as nnf

def mean_filter(x_bchw):
    """
    Calculating the mean of each 3x3 neighborhood.
    input:
    - x_bchw: input tensor of dimensions batch-channel-height-width
    output:
    - y_bchw: each element in y is the average of the 9 corresponding elements in x_bchw
    """
    # define the filter
    box = torch.ones((3, 3), dtype=x_bchw.dtype, device=x_bchw.device, requires_grad=False)
    box = box / box.sum()
    box = box[None, None, ...].repeat(x_bchw.size(1), 1, 1, 1)
    # use grouped convolution - so each channel is averaged separately.
    y_bchw = nnf.conv2d(x_bchw, box, padding=1, groups=x_bchw.size(1))
    return y_bchw

# Cell
def visualize_array(array,alpha=0.8):
    fig, ax = plt.subplots()
    return ax.imshow(array, interpolation='none', alpha=alpha)

# Cell
def extrapolate(t,factor=None,size=None):
    t     = torch.Tensor(t)
    t     = t.unsqueeze(0)
    t     = torch.nn.functional.upsample(t, scale_factor=factor,size=size)
    t     = t.squeeze(0).T.unsqueeze(0)
    t     = torch.nn.functional.upsample(t, scale_factor=factor,size=size)
    return  t.squeeze(0).T

# Cell
def expand_boundaries(t,times=5,factor=5):
    t = extrapolate(t,factor=1/factor)
    t = t[None, None, ...].repeat(t.size(1), 1, 1, 1)
    for _ in range(times):
        t = mean_filter(t)
        t[t>0] = 1

    t = t[0,0,:]
    return extrapolate(t,factor).numpy()

# Cell
def crop_center_arr(arr,shape):
    left  = int((arr.shape[1]-shape)/2)
    right =      left+shape
    up    = int((arr.shape[0]-shape)/2)
    down  =      up+shape
    return arr[left:right, up:down]

# Cell
def apply_mask(img,mask):
    rop_mask = np.array(mask).astype('int')
    return np.array(img) * np.stack([mask]*3).T

# Cell
def crop_zeros(img_arr):

    true_points = np.argwhere(img_arr)
    top_left = true_points.min(axis=0)
    bottom_right = true_points.max(axis=0)
    return (img_arr[top_left[0]:bottom_right[0]+1,
                      top_left[1]:bottom_right[1]+1]).astype(np.uint8)

# Cell
def crop_image_to_square(img):
    height = img.size[1]//2*2
    left  = int((img.size[0]-height)/2)
    right =      img.size[0]-left
    return img.crop((left,0,right,height))

# Cell
def search_clip(url,foods,food_clips,head = 1):
    image_clip = requests.post(f'http://127.0.0.1:8182/image2vector/?url={url}').json()
    image_clip = torch.tensor(image_clip)
    df = foods.copy()
    df['score'] = cos(food_clips,image_clip)
    df = df.sort_values('score',ascending=False)[:head]

    return image_clip,df.reset_index()
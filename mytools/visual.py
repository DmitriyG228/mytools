# AUTOGENERATED! DO NOT EDIT! File to edit: 00_visual.ipynb (unless otherwise specified).

__all__ = ['mean_filter', 'visualize_array', 'extrapolate', 'expand_boundaries', 'crop_center_arr', 'apply_mask',
           'crop_zeros', 'crop_image_to_square', 'search_clip']

# Cell
from .tools import *
import numpy as np
import torch
from matplotlib import pyplot as plt
import requests
import pandas as pd

# Cell
from matplotlib import pyplot as plt
import io
import seaborn as sb
from matplotlib.colors import ListedColormap,LinearSegmentedColormap
from PIL import Image
plt.rcParams['figure.figsize'] = (70,70)

# Cell
#https://stackoverflow.com/questions/59831211/neighbours-of-a-cell-in-matrix-pytorch
import torch.nn.functional as nnf

def mean_filter(x_bchw):
    """
    Calculating the mean of each 3x3 neighborhood.
    input:
    - x_bchw: input tensor of dimensions batch-channel-height-width
    output:
    - y_bchw: each element in y is the average of the 9 corresponding elements in x_bchw
    """
    # define the filter
    box = torch.ones((3, 3), dtype=x_bchw.dtype, device=x_bchw.device, requires_grad=False)
    box = box / box.sum()
    box = box[None, None, ...].repeat(x_bchw.size(1), 1, 1, 1)
    # use grouped convolution - so each channel is averaged separately.
    y_bchw = nnf.conv2d(x_bchw, box, padding=1, groups=x_bchw.size(1))
    return y_bchw

# Cell
def visualize_array(array,back_img = None,alpha=0.3,size = 500,colors = ["white","lime","green","yellow","orange", "red","purple"],values = [0,1,50,100,200,300,400],vmin=5):

    l = list(zip([v/max(values) for v in values],colors))
    cmap=LinearSegmentedColormap.from_list('hmap',l)
    if not array.T.shape == back_img.size:array = extrapolate(array,size = size)
    fig, ax = plt.subplots(figsize=(15,15))
    ax.axes.xaxis.set_visible(False)
    ax.axes.yaxis.set_visible(False)

    sb.heatmap(array, alpha=0.8,cmap=cmap,vmin=vmin, vmax=max(values),cbar=False)
    ax.imshow(back_img, interpolation='none', alpha=1)

    buf = io.BytesIO()
    fig.savefig(buf)
    buf.seek(0)
    return Image.open(buf)

# Cell
def extrapolate(t,factor=None,size=None):
    t     = torch.Tensor(t)
    t     = t.unsqueeze(0)
    t     = torch.nn.functional.upsample(t, scale_factor=factor,size=size)
    t     = t.squeeze(0).T.unsqueeze(0)
    t     = torch.nn.functional.upsample(t, scale_factor=factor,size=size)
    return  t.squeeze(0).T

# Cell
def expand_boundaries(t,times=5,factor=5):
    init_size = t.shape[0]
    t = extrapolate(t,factor=1/factor)
    t = t[None, None, ...].repeat(t.size(1), 1, 1, 1)
    for _ in range(times):
        t = mean_filter(t)
        t[t>0] = 1

    t = t[0,0,:]
    return extrapolate(t,size=init_size).numpy()

# Cell
def crop_center_arr(arr,shape):
    left  = int((arr.shape[1]-shape)/2)
    right =      left+shape
    up    = int((arr.shape[0]-shape)/2)
    down  =      up+shape
    return arr[left:right, up:down]

# Cell
def apply_mask(img,mask):
    mask = np.array(mask).astype('int')
    img = np.array(img)
    # if img[:,:,0].shape !=mask.shape:
    #     df = pd.DataFrame([mask.shape,img.shape[:-1]])
    #     df.iloc[0] = -df.iloc[0]
    #     mask = mask[:-1,:] if df.sum().tolist() ==[0, -1]  else mask[:,:-1]


    return img * np.stack([mask]*3).T

# Cell
def crop_zeros(img_arr):

    true_points = np.argwhere(img_arr)
    top_left = true_points.min(axis=0)
    bottom_right = true_points.max(axis=0)
    return (img_arr[top_left[0]:bottom_right[0]+1,
                      top_left[1]:bottom_right[1]+1]).astype(np.uint8)

# Cell
def crop_image_to_square(img,get_adj = False):
    size = max(img.size)

    x_adj = int((img.size[0]-size)/2)
    y_adj = int((img.size[1]-size)/2)


    img =  img.crop((x_adj,y_adj,size+x_adj,size+y_adj))


    if get_adj: return img, (x_adj,y_adj,size)
    else      : return img

# Cell
def search_clip(url,foods,food_clips,head = 1):
    image_clip = requests.post(f'http://127.0.0.1:8182/image2vector/?url={url}').json()
    image_clip = torch.tensor(image_clip)
    df = foods.copy()
    df['score'] = cos(food_clips,image_clip)
    df = df.sort_values('score',ascending=False)[:head]

    return image_clip,df.reset_index()